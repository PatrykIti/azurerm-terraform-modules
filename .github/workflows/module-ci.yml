name: Module CI

on:
  pull_request:
    paths:
      - 'modules/**'
      - 'shared/**'
      - '.github/workflows/module-ci.yml'
      - '.github/actions/**'
  push:
    branches:
      - main
      - 'release/**'
    paths:
      - 'modules/**'
      - 'shared/**'
  workflow_dispatch:
    inputs:
      test_type:
        description: 'Type of tests to run'
        required: true
        default: 'short'
        type: choice
        options:
          - short
          - full
          - integration-only
      module:
        description: 'Specific module to test (leave empty for all)'
        required: false
        type: string

permissions:
  contents: read
  pull-requests: write
  id-token: write
  security-events: write

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      modules: ${{ steps.filter.outputs.changes || steps.pr-module.outputs.modules }}
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      
      # Extract module from PR title if it's a PR
      - name: Extract module from PR title
        id: pr-module
        if: github.event_name == 'pull_request'
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          echo "PR Title: $PR_TITLE"
          
          # Extract module name from PR title patterns like:
          # - feat(azurerm_virtual_network): ...
          # - fix(azurerm_storage_account): ...
          # - chore(azurerm_resource_group): ...
          if [[ "$PR_TITLE" =~ \(([a-zA-Z0-9_]+)\): ]]; then
            MODULE_NAME="${BASH_REMATCH[1]}"
            echo "Detected module from PR title: $MODULE_NAME"
            
            # Check if the module directory exists
            if [ -d "modules/$MODULE_NAME" ]; then
              echo "modules=[\"$MODULE_NAME\"]" >> $GITHUB_OUTPUT
              echo "Module directory exists: modules/$MODULE_NAME"
            else
              echo "Warning: Module directory modules/$MODULE_NAME does not exist"
              echo "modules=[]" >> $GITHUB_OUTPUT
            fi
          else
            echo "No module detected in PR title, will use path-based detection"
            echo "modules=[]" >> $GITHUB_OUTPUT
          fi
      
      # Dynamically generate filters based on existing modules
      - name: Generate path filters
        id: generate-filters
        run: |
          FILTERS=""
          for module_dir in modules/*/; do
            if [ -d "$module_dir" ]; then
              module_name=$(basename "$module_dir")
              FILTERS="${FILTERS}${module_name}:\n  - 'modules/${module_name}/**'\n  - 'shared/**'\n"
            fi
          done
          echo -e "$FILTERS" > .github/filters.yml
          echo "Generated filters:"
          cat .github/filters.yml
      
      - uses: dorny/paths-filter@v3
        id: filter
        if: steps.pr-module.outputs.modules == '[]' || github.event_name != 'pull_request'
        with:
          filters: .github/filters.yml
      
      - id: set-matrix
        run: |
          # For manual runs with specific module
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.module }}" ]]; then
            MODULES='["${{ github.event.inputs.module }}"]'
          # For PRs with module in title
          elif [[ "${{ github.event_name }}" == "pull_request" && "${{ steps.pr-module.outputs.modules }}" != "[]" ]]; then
            MODULES='${{ steps.pr-module.outputs.modules }}'
          # For path-based detection
          else
            MODULES='${{ steps.filter.outputs.changes }}'
          fi
          
          echo "Final modules to test: $MODULES"
          
          if [ "$MODULES" == "[]" ]; then
            echo "matrix={\"module\":[]}" >> $GITHUB_OUTPUT
          else
            echo "matrix={\"module\":${MODULES}}" >> $GITHUB_OUTPUT
          fi

  validate:
    needs: detect-changes
    if: ${{ needs.detect-changes.outputs.modules != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: ./.github/actions/terraform-setup
        with:
          terraform-version: ${{ vars.TERRAFORM_VERSION || '1.10.3' }}
          install-tflint: true
        
      - name: Validate Module ${{ matrix.module }}
        uses: ./.github/actions/module-runner
        with:
          module: ${{ matrix.module }}
          action: validate
          terraform-version: ${{ vars.TERRAFORM_VERSION || '1.10.3' }}
          github-token: ${{ secrets.PAT }}

  test:
    needs: [detect-changes, validate]
    if: ${{ needs.detect-changes.outputs.modules != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Test Module ${{ matrix.module }}
        uses: ./.github/actions/module-runner
        with:
          module: ${{ matrix.module }}
          action: test
          azure-credentials: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}"
            }

  security-scan:
    needs: detect-changes
    if: ${{ needs.detect-changes.outputs.modules != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Security Scan Module ${{ matrix.module }}
        uses: ./.github/actions/module-runner
        with:
          module: ${{ matrix.module }}
          action: security
          github-token: ${{ secrets.PAT }}

  quality-summary:
    name: CI Summary
    runs-on: ubuntu-latest
    needs: [validate, test, security-scan]
    if: always()
    steps:
      - name: Quality gates summary
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          script: |
            const jobs = ${{ toJSON(needs) }};
            const jobNames = {
              'validate': 'Module Validation',
              'test': 'Module Testing',
              'security-scan': 'Security Scan'
            };
            
            let allPassed = true;
            let summary = '## 🔍 Module CI Summary\n\n';
            summary += '| Check | Status |\n';
            summary += '|-------|--------|\n';
            
            for (const [job, result] of Object.entries(jobs)) {
              const status = result.result === 'success' ? '✅ Passed' : 
                           result.result === 'skipped' ? '⏭️ Skipped' : '❌ Failed';
              if (result.result === 'failure') allPassed = false;
              summary += `| ${jobNames[job] || job} | ${status} |\n`;
            }
            
            summary += '\n';
            
            if (allPassed) {
              summary += '### ✅ All quality gates passed!\n\n';
              summary += 'This PR is ready for review.';
            } else {
              summary += '### ❌ Some quality gates failed\n\n';
              summary += 'Please address the failing checks before this PR can be merged.';
            }
            
            // Find and update existing comment or create new one
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Module CI Summary')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: summary
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summary
              });
            }