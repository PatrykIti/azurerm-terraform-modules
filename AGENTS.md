# AGENTS.md

Condensed, repo-specific guidance for building and maintaining Terraform modules.
This summary is based on `docs/MODULE_GUIDE/*` plus existing repo conventions for CI/CD, releases, and documentation.

## Core Standards

- **Naming**: module folders must be `azurerm_<resource>` or `azuredevops_<resource>`.
- **Gold standard**: `modules/azurerm_kubernetes_cluster` defines the canonical structure and style; document any deviations required by resource-specific constraints.
- **Security-first**: secure defaults are the easiest path; document risks explicitly.
- **Consistency**: consistent structure, naming, and patterns across all modules.

## Design Philosophy (Atomic Modules)

- **Atomic, single-resource modules**: one primary resource per module, no submodules/nesting; composition happens in environment/config repositories.
- **No bundled cross-resource glue**: private endpoints, role assignments/RBAC, budgets, and networking glue live in dedicated modules or higher-level configs.
- **Diagnostic settings inline**: keep diag settings inside each module (duplication accepted) instead of a shared submodule to avoid coupling releases across modules.

## Required Module Layout

```
modules/<provider>_<resource>/
  main.tf, variables.tf, outputs.tf, versions.tf
  README.md, CHANGELOG.md, VERSIONING.md, CONTRIBUTING.md, SECURITY.md
  module.json, .releaserc.js, .terraform-docs.yml, Makefile, generate-docs.sh
  docs/IMPORT.md
  examples/{basic,complete,secure}/(.terraform-docs.yml, main.tf, variables.tf, outputs.tf, README.md)
  tests/{fixtures,unit}/ + Go terratest files + tests/Makefile + tests/tooling scripts + test_outputs/
```

## Terraform Implementation Rules

- `versions.tf`: pin Terraform and providers (repo standard uses `azurerm` 4.57.0); add other providers only when used by the module.
- `variables.tf`: every variable needs description + type; prefer `object()` and `list(object)` for structured inputs; add validation blocks.
- `main.tf`: use `locals` for shared values; dynamic blocks for optional features; `for_each` over `list(object)` for child resources; use `lifecycle` preconditions for cross-field rules.
- `outputs.tf`: include descriptions; mark sensitive outputs; use `try()` for safety.

## Documentation Rules

- README is mostly generated by `terraform-docs`; keep markers:
  - `<!-- BEGIN_VERSION --> ... <!-- END_VERSION -->`
  - `<!-- BEGIN_EXAMPLES --> ... <!-- END_EXAMPLES -->`
  - `<!-- BEGIN_TF_DOCS --> ... <!-- END_TF_DOCS -->`
- Regenerate docs via `make docs`, `./generate-docs.sh`, or `./scripts/update-module-docs.sh <module>`.
- Update examples list with `./scripts/update-examples-list.sh <module>`.
- Version marker is updated by `./scripts/update-module-version.sh <module> <version>`.
- Example READMEs must be clear and runnable.

## Examples Expectations

- Must include `basic`, `complete`, `secure` examples; optional feature-specific examples follow AKS patterns (e.g., `diagnostic-settings`, `multi-node-pool`, `workload-identity`).
- Self-contained: create their own RG and dependencies where feasible.
- Naming: examples use fixed names; only Go E2E tests use dynamic/random suffixes.

## Testing Expectations

- Layers: `terraform fmt/validate` + security scan, `terraform test` unit tests, Terratest integration.
- Standard structure: `tests/unit/*.tftest.hcl`, `tests/fixtures/*`, `go.mod`, `go.sum`, `test_config.yaml`, `test_env.sh`,
  `run_tests_parallel.sh`, `run_tests_sequential.sh`, `integration_test.go`, `performance_test.go`, and module-specific test files.
- All tests should pass locally before PR.

## CI/CD and Releases

- Workflows: `pr-validation.yml` (fast checks), `module-ci.yml` (full tests), `module-release.yml` (semantic-release).
- `module.json` drives release scope and tag prefix; `.releaserc.js` reads it.
- Use conventional commits with module scope: `feat(<scope>): ...`, `fix(<scope>): ...`.
- Releases auto-generate `CHANGELOG.md` and tags like `<TAG_PREFIX>vX.Y.Z`.

## GitHub Actions Guidelines (Summary)

- Pin Terraform version; run `fmt`, `init -backend=false`, `validate`.
- Use OIDC for Azure in CI when needed (`ARM_USE_OIDC=1` + `azure/login`).
- Use path-based filtering; only run CI for changed modules.
- Security scanning should be part of CI (Trivy/Checkov or repo standard).
